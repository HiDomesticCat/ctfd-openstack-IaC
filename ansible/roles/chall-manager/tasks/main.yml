# roles/chall-manager/tasks/main.yml

- name: 確保 zip 和 git 已安裝
  apt:
    name:
      - zip
      - git
    state: present
    update_cache: no
    become: yes

# ── 安裝 Go（用於編譯 scenario binary）──────────────────────
- name: 檢查 Go 是否已安裝且版本正確
  shell: /usr/local/go/bin/go version 2>/dev/null | grep -q "go{{ go_version }}" && echo "ok" || echo "missing"
  args:
    executable: /bin/bash
  register: go_check
  changed_when: false

- name: 安裝 Go {{ go_version }}
  block:
    - name: 下載 Go 壓縮包
      get_url:
        url: "https://go.dev/dl/go{{ go_version }}.linux-amd64.tar.gz"
        dest: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        mode: "0644"

    - name: 移除舊版 Go（若有）
      file:
        path: /usr/local/go
        state: absent

    - name: 解壓 Go 到 /usr/local
      unarchive:
        src: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        dest: /usr/local/
        remote_src: yes

    - name: 清理暫存壓縮包
      file:
        path: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        state: absent
  when: go_check.stdout != "ok"
  become: yes

# ── 允許使用 insecure local registry ─────────────────────────
# Docker 預設不允許 HTTP registry，需要設定白名單
- name: 確保 /etc/docker 目錄存在
  file:
    path: /etc/docker
    state: directory
    mode: "0755"

- name: 設定 Docker 允許 insecure local registry
  copy:
    dest: /etc/docker/daemon.json
    content: |
      {
        "insecure-registries": ["{{ registry_host }}:{{ registry_port }}"]
      }
    mode: "0644"
  register: docker_daemon_updated

- name: 重啟 Docker（若 daemon.json 有變更）
  systemd:
    name: docker
    state: restarted
  when: docker_daemon_updated.changed

# ── 安裝 oras CLI（推送 OCI artifact 到 local registry）────────
# chall-manager 的 scenario 是 zip OCI artifact，不是 Docker image
- name: 檢查 oras 是否已安裝且版本正確
  shell: oras version 2>/dev/null | grep -q "{{ oras_version }}" && echo "ok" || echo "missing"
  args:
    executable: /bin/bash
  register: oras_check
  changed_when: false

- name: 安裝 oras CLI v{{ oras_version }}
  block:
    - name: 下載 oras 壓縮包
      get_url:
        url: "https://github.com/oras-project/oras/releases/download/v{{ oras_version }}/oras_{{ oras_version }}_linux_amd64.tar.gz"
        dest: "/tmp/oras_{{ oras_version }}.tar.gz"
        mode: "0644"

    - name: 解壓 oras 到 /usr/local/bin
      unarchive:
        src: "/tmp/oras_{{ oras_version }}.tar.gz"
        dest: /usr/local/bin/
        remote_src: yes
        include:
          - oras
        mode: "0755"

    - name: 清理暫存壓縮包
      file:
        path: "/tmp/oras_{{ oras_version }}.tar.gz"
        state: absent
  when: oras_check.stdout != "ok"

# ── 建立目錄 ──────────────────────────────────────────────
- name: 建立 chall-manager 根目錄
  file:
    path: "{{ chall_manager_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

- name: 建立 scenarios 目錄
  file:
    path: "{{ chall_manager_scenarios_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

# ── 同步 scenarios 原始碼到遠端 ───────────────────────────────
- name: 同步 scenarios/ 到遠端（rsync）
  synchronize:
    src: "{{ playbook_dir }}/scenarios/"
    dest: "{{ chall_manager_scenarios_dir }}/"
    delete: yes
    recursive: yes
    rsync_opts:
      - "--exclude='.git'"
      - "--exclude='venv/'"
      - "--exclude='__pycache__/'"
      - "--exclude='*.pyc'"
      - "--chown=ubuntu:ubuntu"

# ── 部署 Docker Compose（registry + chall-manager + etcd）─────
- name: 渲染 chall-manager docker-compose.yml
  template:
    src: docker-compose.yml.j2
    dest: "{{ chall_manager_dir }}/docker-compose.yml"
    mode: "0644"
    owner: ubuntu
    group: ubuntu
  register: compose_updated

- name: 啟動 chall-manager 服務（含 registry 和 etcd）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    state: present

- name: 重啟 chall-manager（若 compose 有變更）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    state: present
    recreate: always
  when: compose_updated.changed

# ── 等待 registry 就緒 ─────────────────────────────────────
- name: 等待 local registry 就緒
  uri:
    url: "http://{{ registry_host }}:{{ registry_port }}/v2/"
    status_code: 200
  register: registry_ready
  until: registry_ready.status == 200
  retries: 12
  delay: 5

# ── Build + Push scenario 為 OCI artifact（zip）──────────────
# chall-manager 讀取的是 zip 格式的 OCI artifact，不是 Docker image
# 使用 oras CLI 推送 zip 到 local registry
- name: 找出所有含 Pulumi.yaml 或 Pulumi.yml 的 scenario 目錄
  find:
    paths: "{{ chall_manager_scenarios_dir }}"
    # ✅ 同時支援 .yaml 和 .yml 兩種副檔名
    patterns:
      - "Pulumi.yaml"
      - "Pulumi.yml"
    recurse: yes
  register: scenario_pulumi_files

- name: 編譯 Go binary 並打包各 scenario 為 OCI artifact
  shell: |
    set -e
    export PATH="/usr/local/go/bin:${PATH}"

    scenario_dir="{{ item.path | dirname }}"
    scenario_name="{{ item.path | dirname | basename }}"
    image_tag="{{ registry_url }}/${scenario_name}:latest"
    state_file="/tmp/.scenario_${scenario_name}_hash"

    echo "==> Building Go binary for ${scenario_name} ..."
    cd "${scenario_dir}"

    # ✅ Go runtime：編譯 binary（chall-manager 只支援 Go，不支援 Python）
    if [ -f go.mod ]; then
      go mod tidy
      go mod download
      CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o main .
      echo "==> Go build complete"
    else
      echo "WARNING: no go.mod found in ${scenario_dir}, skipping build"
    fi

    # ── 計算 source hash（排除 compiled binary）─────────────
    src_hash=$(find "${scenario_dir}" \
      -not -path "*/.git/*" \
      -not -name "main" \
      -type f | sort | xargs sha256sum 2>/dev/null | sha256sum | cut -c1-12)
    prev_hash=$(cat "${state_file}" 2>/dev/null || echo "")

    # ── Push：每個檔案為獨立 layer（chall-manager 規範格式）──
    # Minimal artifact：Pulumi.yml + main binary
    echo "==> Pushing OCI artifact → ${image_tag} ..."
    oras push \
      --insecure \
      --disable-path-validation \
      --artifact-type application/vnd.ctfer-io.scenario \
      "${image_tag}" \
      main:application/vnd.ctfer-io.file \
      Pulumi.yml:application/vnd.ctfer-io.file

    # ── 變更偵測，決定是否重啟 chall-manager ────────────────
    if [ "${src_hash}" != "${prev_hash}" ]; then
      echo "${src_hash}" > "${state_file}"
      echo "changed:${image_tag}"
    else
      echo "unchanged:${image_tag}"
    fi
  args:
    executable: /bin/bash
  loop: "{{ scenario_pulumi_files.files }}"
  async: 600
  poll: 15
  register: scenario_build_results

- name: 顯示 build 結果
  debug:
    msg: "{{ item.stdout_lines | default([]) | select('match', '^(==>|done:|changed:|unchanged:)') | list }}"
  loop: "{{ scenario_build_results.results }}"

# ✅ 若任一 scenario source 有變更，重啟 chall-manager 以載入新 artifact
- name: 重啟 chall-manager（若有 scenario 更新）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    services:
      - chall-manager
    state: present
    recreate: always
  when: >-
    scenario_build_results.results
    | selectattr('stdout', 'defined')
    | selectattr('stdout', 'search', 'changed:')
    | list | length > 0

# ── 確認 chall-manager Port 就緒 ──────────────────────────────
# chall-manager 是 gRPC 服務，沒有 REST /health endpoint
# 改用 TCP port 檢查確認服務已啟動
- name: 等待 chall-manager port 就緒（最多 60 秒）
  wait_for:
    host: 127.0.0.1
    port: "{{ chall_manager_port }}"
    timeout: 60
    state: started

- name: 顯示完成資訊
  debug:
    msg:
      - "✅ chall-manager API  : http://127.0.0.1:{{ chall_manager_port }}"
      - "✅ Local registry     : http://{{ registry_url }}"
      - "   CTFd 外掛設定 → API URL: http://127.0.0.1:{{ chall_manager_port }}"
      - "   CTFd 題目 Scenario : registry:{{ registry_port }}/openstack-vm:latest"
      - "   （注意：CTFd 在 Docker network 內要用 registry:{{ registry_port }}，不是 localhost）"
