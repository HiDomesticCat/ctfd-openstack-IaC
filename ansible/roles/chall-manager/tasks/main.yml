# roles/chall-manager/tasks/main.yml

- name: 確保 zip 和 git 已安裝
  apt:
    name:
      - zip
      - git
    state: present
    update_cache: no
  become: yes

# ── 安裝 Go（用於編譯 scenario binary）──────────────────────
- name: 檢查 Go 是否已安裝且版本正確
  shell: /usr/local/go/bin/go version 2>/dev/null | grep -q "go{{ go_version }}" && echo "ok" || echo "missing"
  args:
    executable: /bin/bash
  register: go_check
  changed_when: false

- name: 安裝 Go {{ go_version }}
  block:
    - name: 下載 Go 壓縮包
      get_url:
        url: "https://go.dev/dl/go{{ go_version }}.linux-amd64.tar.gz"
        dest: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        mode: "0644"

    - name: 移除舊版 Go（若有）
      file:
        path: /usr/local/go
        state: absent

    - name: 解壓 Go 到 /usr/local
      unarchive:
        src: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        dest: /usr/local/
        remote_src: yes

    - name: 清理暫存壓縮包
      file:
        path: "/tmp/go{{ go_version }}.linux-amd64.tar.gz"
        state: absent
  when: go_check.stdout != "ok"

# ── 允許使用 insecure local registry ─────────────────────────
# Docker 預設不允許 HTTP registry，需要設定白名單
- name: 確保 /etc/docker 目錄存在
  file:
    path: /etc/docker
    state: directory
    mode: "0755"

- name: 設定 Docker 允許 insecure local registry
  copy:
    dest: /etc/docker/daemon.json
    content: |
      {
        "insecure-registries": ["{{ registry_host }}:{{ registry_port }}"]
      }
    mode: "0644"
  register: docker_daemon_updated

- name: 重啟 Docker（若 daemon.json 有變更）
  systemd:
    name: docker
    state: restarted
  when: docker_daemon_updated.changed

# ── 安裝 oras CLI（推送 OCI artifact 到 local registry）────────
# chall-manager 的 scenario 是 zip OCI artifact，不是 Docker image
- name: 檢查 oras 是否已安裝且版本正確
  shell: oras version 2>/dev/null | grep -q "{{ oras_version }}" && echo "ok" || echo "missing"
  args:
    executable: /bin/bash
  register: oras_check
  changed_when: false

- name: 安裝 oras CLI v{{ oras_version }}
  block:
    - name: 下載 oras 壓縮包
      get_url:
        url: "https://github.com/oras-project/oras/releases/download/v{{ oras_version }}/oras_{{ oras_version }}_linux_amd64.tar.gz"
        dest: "/tmp/oras_{{ oras_version }}.tar.gz"
        mode: "0644"

    - name: 解壓 oras 到 /usr/local/bin
      unarchive:
        src: "/tmp/oras_{{ oras_version }}.tar.gz"
        dest: /usr/local/bin/
        remote_src: yes
        include:
          - oras
        mode: "0755"

    - name: 清理暫存壓縮包
      file:
        path: "/tmp/oras_{{ oras_version }}.tar.gz"
        state: absent
  when: oras_check.stdout != "ok"

# ── 建立目錄 ──────────────────────────────────────────────
- name: 建立 chall-manager 根目錄
  file:
    path: "{{ chall_manager_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

- name: 建立 scenarios 目錄
  file:
    path: "{{ chall_manager_scenarios_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

# ✅ 必須在 Docker Compose 啟動前建立，否則 Docker 會以 root 建立目錄
# 導致容器內 chall-manager 無法寫入 OCI cache
- name: 建立 OCI cache 目錄（供 bind mount 使用）
  file:
    path: "{{ chall_manager_dir }}/cache"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

# ── 同步 scenarios 原始碼到遠端 ───────────────────────────────
- name: 同步 scenarios/ 到遠端（rsync）
  synchronize:
    src: "{{ playbook_dir }}/scenarios/"
    dest: "{{ chall_manager_scenarios_dir }}/"
    delete: yes
    recursive: yes
    rsync_opts:
      - "--exclude='.git'"
      - "--exclude='venv/'"
      - "--exclude='__pycache__/'"
      - "--exclude='*.pyc'"
      - "--chown=ubuntu:ubuntu"

# ── 部署 Docker Compose（registry + chall-manager + etcd）─────
- name: 渲染 chall-manager docker-compose.yml
  template:
    src: docker-compose.yml.j2
    dest: "{{ chall_manager_dir }}/docker-compose.yml"
    mode: "0644"
    owner: ubuntu
    group: ubuntu
  register: compose_updated

- name: 啟動/更新 chall-manager 服務
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    state: present
    # ✅ recreate: auto（預設值）：Docker Compose 比對 container config hash，
    # 只要正在跑的 container 和 compose 定義有任何差異就重建。
    # 比 compose_updated.changed 更可靠：
    #   - compose_updated.changed 只偵測「檔案是否有改」
    #   - 如果手動修改過 container 或 compose 檔案曾被覆蓋再還原，Ansible 不會察覺
    # Docker Compose 的 hash 比對是唯一可信的 source of truth
    recreate: auto

# ── 等待 registry 就緒 ─────────────────────────────────────
- name: 等待 local registry 就緒
  uri:
    url: "http://{{ registry_host }}:{{ registry_port }}/v2/"
    status_code: 200
  register: registry_ready
  until: registry_ready.status == 200
  retries: 12
  delay: 5

# ── Build + Push scenario 為 OCI artifact（zip）──────────────
# chall-manager 讀取的是 zip 格式的 OCI artifact，不是 Docker image
# 使用 oras CLI 推送 zip 到 local registry
- name: 找出所有含 Pulumi.yaml 或 Pulumi.yml 的 scenario 目錄
  find:
    paths: "{{ chall_manager_scenarios_dir }}"
    # ✅ 同時支援 .yaml 和 .yml 兩種副檔名
    patterns:
      - "Pulumi.yaml"
      - "Pulumi.yml"
    recurse: yes
  register: scenario_pulumi_files

- name: 編譯 Go binary 並打包各 scenario 為 OCI artifact
  shell: |
    set -e
    export PATH="/usr/local/go/bin:${PATH}"

    scenario_dir="{{ item.path | dirname }}"
    scenario_name="{{ item.path | dirname | basename }}"
    image_tag="{{ registry_url }}/${scenario_name}:latest"
    state_file="/tmp/.scenario_${scenario_name}_hash"

    echo "==> Building Go binary for ${scenario_name} ..."
    cd "${scenario_dir}"

    # ✅ Go runtime：編譯 binary（chall-manager 只支援 Go，不支援 Python）
    if [ -f go.mod ]; then
      go mod tidy
      go mod download
      CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -trimpath -o main .
      echo "==> Go build complete"
    else
      echo "WARNING: no go.mod found in ${scenario_dir}, skipping build"
    fi

    # ── 計算 source hash（排除 compiled binary）─────────────
    src_hash=$(find "${scenario_dir}" \
      -not -path "*/.git/*" \
      -not -name "main" \
      -type f | sort | xargs sha256sum 2>/dev/null | sha256sum | cut -c1-12)
    prev_hash=$(cat "${state_file}" 2>/dev/null || echo "")

    # ── Push：每個檔案為獨立 layer（chall-manager 規範格式）──
    # Minimal artifact：Pulumi.yaml + main binary
    # ✅ 推送 Pulumi.yaml（chall-manager cache 以 .yaml 副檔名索引，不接受 .yml）
    echo "==> Pushing OCI artifact → ${image_tag} ..."
    pulumi_file="Pulumi.yaml"
    if [ ! -f "${pulumi_file}" ] && [ -f "Pulumi.yml" ]; then
      pulumi_file="Pulumi.yml"
    fi
    oras push \
      --insecure \
      --disable-path-validation \
      --artifact-type application/vnd.ctfer-io.scenario \
      "${image_tag}" \
      main:application/vnd.ctfer-io.file \
      "${pulumi_file}:application/vnd.ctfer-io.file"

    # ── 變更偵測，決定是否重啟 chall-manager ────────────────
    if [ "${src_hash}" != "${prev_hash}" ]; then
      echo "${src_hash}" > "${state_file}"
      echo "changed:${image_tag}"
    else
      echo "unchanged:${image_tag}"
    fi
  args:
    executable: /bin/bash
  loop: "{{ scenario_pulumi_files.files }}"
  async: 600
  poll: 15
  register: scenario_build_results

- name: 顯示 build 結果
  debug:
    msg: "{{ item.stdout_lines | default([]) | select('match', '^(==>|done:|changed:|unchanged:)') | list }}"
  loop: "{{ scenario_build_results.results }}"

# ✅ 做法二：用 Ansible file 模組清除 bind mount 的 OCI cache 目錄
# 比 docker exec rm 更可靠：直接操作 VM 實體目錄，不受容器狀態影響
# 比 tmpfs 更安全：允許執行 binary（tmpfs 預設 noexec 會讓 main 執行失敗）
- name: 清除 chall-manager OCI cache 目錄（避免 stale file）
  file:
    path: "{{ chall_manager_dir }}/cache"
    state: absent
  when: >-
    scenario_build_results.results
    | selectattr('stdout', 'defined')
    | selectattr('stdout', 'search', 'changed:')
    | list | length > 0

- name: 重建乾淨的 cache 目錄（供 bind mount 使用）
  file:
    path: "{{ chall_manager_dir }}/cache"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu
  when: >-
    scenario_build_results.results
    | selectattr('stdout', 'defined')
    | selectattr('stdout', 'search', 'changed:')
    | list | length > 0

# ✅ 若任一 scenario source 有變更，重啟 chall-manager 以載入新 artifact
- name: 重啟 chall-manager（若有 scenario 更新）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    services:
      - chall-manager
    state: present
    recreate: always
  when: >-
    scenario_build_results.results
    | selectattr('stdout', 'defined')
    | selectattr('stdout', 'search', 'changed:')
    | list | length > 0

# ── 確認 chall-manager Port 就緒 ──────────────────────────────
# chall-manager 是 gRPC 服務，沒有 REST /health endpoint
# 改用 TCP port 檢查確認服務已啟動
- name: 等待 chall-manager port 就緒（最多 60 秒）
  wait_for:
    host: 127.0.0.1
    port: "{{ chall_manager_port }}"
    timeout: 60
    state: started

# ── 預熱：預先 pull OCI artifact 至 chall-manager cache ───────
#
# 問題根因：chall-manager 在「第一次使用 scenario」時才從 registry
# 執行 lazy pull。當 Ansible 清除了 OCI cache（scenario 有變更時），
# CTFd admin 按下「創建題目」就會觸發 cold pull，造成 10~30 秒延遲。
#
# 解法：透過 chall-manager REST API（/api/v1/challenge）建立暫時
# warmup challenge，強制觸發 OCI pull 並 cache，再立即刪除。
# 下次 CTFd admin 創建題目時 artifact 已在 cache，回應幾乎即時。
#
# 已確認的 API 格式（由 curl 探索）：
#   POST   http://localhost:8080/api/v1/challenge
#   Body:  {"id":"...","scenario":"registry:5000/<name>:latest","timeout":"300s"}
#   DELETE http://localhost:8080/api/v1/challenge/<id>
# ─────────────────────────────────────────────────────────────

- name: 預熱各 scenario（透過 REST API 觸發 OCI artifact pull + cache）
  shell: |
    set -e
    PORT="{{ chall_manager_port }}"
    SCENARIO="{{ item.path | dirname | basename }}"
    # ✅ 用 Docker service name（registry:5000），不是 localhost:5000
    # chall-manager 在容器內，localhost 指容器本身而非 host
    IMAGE="{{ registry_url_internal }}/${SCENARIO}:latest"
    WARMUP_ID="__warmup_${SCENARIO}__"
    API_BASE="http://localhost:${PORT}/api/v1/challenge"

    echo "==> [${SCENARIO}] 觸發 OCI artifact pull（${IMAGE}）..."

    # 建立暫時 warmup challenge → 強制 chall-manager pull + cache OCI artifact
    # 欄位名稱以實際 API 回應為準：id / scenario / timeout
    CREATE_CODE=$(curl -s -o /tmp/cm_warmup_resp.json -w "%{http_code}" \
      -X POST "${API_BASE}" \
      -H "Content-Type: application/json" \
      -d "{\"id\":\"${WARMUP_ID}\",\"scenario\":\"${IMAGE}\",\"timeout\":\"300s\"}" \
      --max-time 120)

    if [ "${CREATE_CODE}" = "200" ] || [ "${CREATE_CODE}" = "201" ]; then
      echo "==> [${SCENARIO}] OCI artifact 已 cache（HTTP ${CREATE_CODE}）"
    elif [ "${CREATE_CODE}" = "409" ]; then
      echo "==> [${SCENARIO}] warmup challenge 已存在（cache 應已熱），繼續清除..."
    else
      echo "WARN: [${SCENARIO}] create warmup 回應 HTTP ${CREATE_CODE}：$(cat /tmp/cm_warmup_resp.json 2>/dev/null)"
    fi

    # 立即刪除 warmup challenge，保持 chall-manager state 乾淨
    DELETE_CODE=$(curl -s -o /dev/null -w "%{http_code}" \
      -X DELETE "${API_BASE}/${WARMUP_ID}" \
      --max-time 30)

    if [ "${DELETE_CODE}" = "200" ] || [ "${DELETE_CODE}" = "204" ]; then
      echo "DONE: [${SCENARIO}] 預熱完成，CTFd 創建題目將不再有 cold-pull 延遲"
    else
      echo "WARN: [${SCENARIO}] delete warmup 回應 HTTP ${DELETE_CODE}（已忽略）"
      echo "DONE: [${SCENARIO}] 預熱流程完成"
    fi
  args:
    executable: /bin/bash
  loop: "{{ scenario_pulumi_files.files }}"
  register: warmup_results
  changed_when: false
  ignore_errors: yes

- name: 顯示預熱結果
  debug:
    msg: "{{ item.stdout_lines | default([]) | select('match', '^(==>|DONE|WARN)') | list }}"
  loop: "{{ warmup_results.results }}"
  loop_control:
    label: "{{ item.item.path | dirname | basename }}"

- name: 顯示完成資訊
  debug:
    msg:
      - "✅ chall-manager API  : http://127.0.0.1:{{ chall_manager_port }}（host 直接存取）"
      - "✅ Local registry     : http://{{ registry_url }}"
      - "   ─────────────────────────────────────────────────────"
      - "   CTFd 外掛設定 → chall-manager URL: http://chall-manager:{{ chall_manager_port }}"
      - "   （CTFd 容器內走 ctfd_internal Docker network，用 service name 不是 localhost）"
      - "   CTFd 題目 Scenario : registry:{{ registry_port }}/openstack-vm:latest"
      - "   CTFd 題目 Scenario : registry:{{ registry_port }}/k8s-pod:latest"
