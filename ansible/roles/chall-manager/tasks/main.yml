# roles/chall-manager/tasks/main.yml

- name: 確保 python3-venv 和 zip 已安裝
  apt:
    name:
      - python3-venv
      - zip
    state: present
    update_cache: no

# ── 允許使用 insecure local registry ─────────────────────────
# Docker 預設不允許 HTTP registry，需要設定白名單
- name: 確保 /etc/docker 目錄存在
  file:
    path: /etc/docker
    state: directory
    mode: "0755"

- name: 設定 Docker 允許 insecure local registry
  copy:
    dest: /etc/docker/daemon.json
    content: |
      {
        "insecure-registries": ["{{ registry_host }}:{{ registry_port }}"]
      }
    mode: "0644"
  register: docker_daemon_updated

- name: 重啟 Docker（若 daemon.json 有變更）
  systemd:
    name: docker
    state: restarted
  when: docker_daemon_updated.changed

# ── 安裝 oras CLI（推送 OCI artifact 到 local registry）────────
# chall-manager 的 scenario 是 zip OCI artifact，不是 Docker image
- name: 檢查 oras 是否已安裝且版本正確
  shell: oras version 2>/dev/null | grep -q "{{ oras_version }}" && echo "ok" || echo "missing"
  args:
    executable: /bin/bash
  register: oras_check
  changed_when: false

- name: 安裝 oras CLI v{{ oras_version }}
  block:
    - name: 下載 oras 壓縮包
      get_url:
        url: "https://github.com/oras-project/oras/releases/download/v{{ oras_version }}/oras_{{ oras_version }}_linux_amd64.tar.gz"
        dest: "/tmp/oras_{{ oras_version }}.tar.gz"
        mode: "0644"

    - name: 解壓 oras 到 /usr/local/bin
      unarchive:
        src: "/tmp/oras_{{ oras_version }}.tar.gz"
        dest: /usr/local/bin/
        remote_src: yes
        include:
          - oras
        mode: "0755"

    - name: 清理暫存壓縮包
      file:
        path: "/tmp/oras_{{ oras_version }}.tar.gz"
        state: absent
  when: oras_check.stdout != "ok"

# ── 建立目錄 ──────────────────────────────────────────────
- name: 建立 chall-manager 根目錄
  file:
    path: "{{ chall_manager_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

- name: 建立 scenarios 目錄
  file:
    path: "{{ chall_manager_scenarios_dir }}"
    state: directory
    mode: "0755"
    owner: ubuntu
    group: ubuntu

# ── 同步 scenarios 原始碼到遠端 ───────────────────────────────
- name: 同步 scenarios/ 到遠端（rsync）
  synchronize:
    src: "{{ playbook_dir }}/scenarios/"
    dest: "{{ chall_manager_scenarios_dir }}/"
    delete: yes
    recursive: yes
    rsync_opts:
      - "--exclude='.git'"
      - "--exclude='venv/'"
      - "--exclude='__pycache__/'"
      - "--exclude='*.pyc'"
      - "--chown=ubuntu:ubuntu"

# ── 部署 Docker Compose（registry + chall-manager + etcd）─────
- name: 渲染 chall-manager docker-compose.yml
  template:
    src: docker-compose.yml.j2
    dest: "{{ chall_manager_dir }}/docker-compose.yml"
    mode: "0644"
    owner: ubuntu
    group: ubuntu
  register: compose_updated

- name: 啟動 chall-manager 服務（含 registry 和 etcd）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    state: present

- name: 重啟 chall-manager（若 compose 有變更）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    state: present
    recreate: always
  when: compose_updated.changed

# ── 等待 registry 就緒 ─────────────────────────────────────
- name: 等待 local registry 就緒
  uri:
    url: "http://{{ registry_host }}:{{ registry_port }}/v2/"
    status_code: 200
  register: registry_ready
  until: registry_ready.status == 200
  retries: 12
  delay: 5

# ── Build + Push scenario 為 OCI artifact（zip）──────────────
# chall-manager 讀取的是 zip 格式的 OCI artifact，不是 Docker image
# 使用 oras CLI 推送 zip 到 local registry
- name: 找出所有含 Pulumi.yaml 或 Pulumi.yml 的 scenario 目錄
  find:
    paths: "{{ chall_manager_scenarios_dir }}"
    # ✅ 同時支援 .yaml 和 .yml 兩種副檔名
    patterns:
      - "Pulumi.yaml"
      - "Pulumi.yml"
    recurse: yes
  register: scenario_pulumifiles

- name: 安裝 Python venv 並打包各 scenario 為 OCI artifact
  shell: |
    set -e
    scenario_dir="{{ item.path | dirname }}"
    scenario_name="{{ item.path | dirname | basename }}"
    zip_file="/tmp/${scenario_name}.zip"
    state_file="/tmp/.scenario_${scenario_name}_hash"

    # ── 計算 source 內容 hash（排除 venv/pyc 等非源碼檔）─────
    src_hash=$(find "${scenario_dir}" \
      -not -path "*/venv/*" \
      -not -path "*/__pycache__/*" \
      -not -name "*.pyc" \
      -not -name "*.egg-info" \
      -type f | sort | xargs sha256sum 2>/dev/null | sha256sum | cut -c1-12)

    prev_hash=$(cat "${state_file}" 2>/dev/null || echo "")
    versioned_tag="{{ registry_url }}/${scenario_name}:${src_hash}"
    latest_tag="{{ registry_url }}/${scenario_name}:latest"

    echo "==> Preparing Python venv for ${scenario_name} (hash=${src_hash}) ..."
    cd "${scenario_dir}"

    if [ -f requirements.txt ]; then
      python3 -m venv venv
      venv/bin/pip install -q --upgrade pip
      venv/bin/pip install -q -r requirements.txt
    fi

    echo "==> Packaging ${scenario_name} as OCI artifact zip ..."
    rm -f "${zip_file}"
    zip -r "${zip_file}" . \
      -x "*.git*" \
      -x "venv/*" \
      -x "__pycache__/*" \
      -x "*.pyc" \
      -x "*.egg-info/*" \
      -x "Dockerfile" \
      -x ".DS_Store"

    # ── Push with content-hash tag（blobs 相同時快速完成）──────
    echo "==> Pushing OCI artifact → ${versioned_tag} ..."
    cd /tmp
    oras push \
      --insecure \
      --disable-path-validation \
      "${versioned_tag}" \
      "${scenario_name}.zip:application/zip"

    # ✅ 強制把 :latest 指向剛推的內容 hash tag
    # 確保 :latest 一定是最新版本，不依賴 push 是否 skip
    echo "==> Tagging :latest → ${versioned_tag} ..."
    oras tag --insecure "${versioned_tag}" "latest"

    rm -f "${zip_file}"

    # ── 比較 hash，決定是否需要重啟 chall-manager ─────────────
    if [ "${src_hash}" != "${prev_hash}" ]; then
      echo "${src_hash}" > "${state_file}"
      echo "changed:${latest_tag}"
    else
      echo "unchanged:${latest_tag}"
    fi
  args:
    executable: /bin/bash
  loop: "{{ scenario_pulumifiles.files }}"
  register: build_results
  # ✅ async+loop 下 changed_when 無法可靠引用 build_results，
  # 改為執行後用獨立 task 判斷需否 restart
  changed_when: false   # 由下方 restart task 處理
  async: 600
  poll: 15

- name: 顯示 build 結果
  debug:
    msg: "{{ item.stdout_lines | default([]) | select('match', '^(==>|done:|changed:|unchanged:)') | list }}"
  loop: "{{ build_results.results }}"

# ✅ 若任一 scenario source 有變更，重啟 chall-manager 以載入新 artifact
- name: 重啟 chall-manager（若有 scenario 更新）
  community.docker.docker_compose_v2:
    project_src: "{{ chall_manager_dir }}"
    services:
      - chall-manager
    state: present
    recreate: always
  when: >-
    build_results.results
    | selectattr('stdout', 'defined')
    | selectattr('stdout', 'search', 'changed:')
    | list | length > 0

# ── 確認 chall-manager Port 就緒 ──────────────────────────────
# chall-manager 是 gRPC 服務，沒有 REST /health endpoint
# 改用 TCP port 檢查確認服務已啟動
- name: 等待 chall-manager port 就緒（最多 60 秒）
  wait_for:
    host: 127.0.0.1
    port: "{{ chall_manager_port }}"
    timeout: 60
    state: started

- name: 顯示完成資訊
  debug:
    msg:
      - "✅ chall-manager API  : http://127.0.0.1:{{ chall_manager_port }}"
      - "✅ Local registry     : http://{{ registry_url }}"
      - "   CTFd 外掛設定 → API URL: http://127.0.0.1:{{ chall_manager_port }}"
      - "   CTFd 題目 Scenario : registry:{{ registry_port }}/openstack-vm:latest"
      - "   （注意：CTFd 在 Docker network 內要用 registry:{{ registry_port }}，不是 localhost）"
